from types import MappingProxyType
from typing import NoReturn, Tuple, final, ClassVar, Coroutine, Optional, overload, Union, MappingView, Iterable, Iterator

from aiogram.types import Message

from ._base import BaseBot


class QueueStruct:
    @final
    class user:
        def __new__(cls, uid: int, display_name: str) -> QueueStruct.user: ...

        @property
        def uid(self, /) -> int: ...

        @uid.setter
        def uid(self, value: int, /) -> NoReturn: ...

        @property
        def display_name(self, /) -> str: ...

        @display_name.setter
        def display_name(self, value: str, /) -> NoReturn: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

    @final
    class QueueSlot:
        @property
        def uid(self, /) -> Optional[int]: ...

        @property
        def display_name(self, /) -> Optional[str]: ...

        @display_name.setter
        def display_name(self, value: str, /) -> NoReturn: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

    @final
    class Queue:
        @final
        class forward_iterator:
            def __str__(self, /) -> str: ...

            def __repr__(self, /) -> str: ...

            def __iter__(self, /) -> QueueStruct.Queue.forward_iterator: ...

            def __next__(self, /) -> QueueStruct.QueueSlot: ...

        @final
        class reverse_iterator:
            def __str__(self, /) -> str: ...

            def __repr__(self, /) -> str: ...

            def __iter__(self, /) -> QueueStruct.Queue.forward_iterator: ...

            def __next__(self, /) -> QueueStruct.QueueSlot: ...

        @property
        def name(self, /) -> Optional[str]: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

        def __len__(self, /) -> int: ...

        def __getitem__(self, index: int, /) -> QueueStruct.QueueSlot: ...

        def __iter__(self, /) -> forward_iterator: ...

        def __reversed__(self, /) -> reverse_iterator: ...

    @final
    class slot_iterator:
        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

        def __iter__(self, /) -> QueueStruct.Queue.forward_iterator: ...

        def __next__(self, /) -> QueueStruct.QueueSlot: ...

    @overload
    def __new__(cls, /, name: str, queues: Union[dict[Iterable[Optional[user]]], MappingProxyType[Iterable[Optional[user]]]]) -> QueueStruct: ...

    @overload
    def __new__(cls, /, name: str, queues: Iterable[Optional[user]]) -> QueueStruct: ...

    def __len__(self, /) -> int: ...

    def __getitem__(self, index, /) -> Queue: ...

    def __str__(self, /) -> str: ...

    def __repr__(self, /) -> str: ...

    def __iter__(self, /) -> Iterator[Queue]: ...

    def __reversed__(self, /) -> Iterator[Queue]: ...

    def iter_slots(self, /) -> slot_iterator: ...


class QueueMessage(QueueStruct):
    class MessageKey:
        pass


class QueueSynchronizer:
    DELAY: ClassVar[float] = ...

    class CommonMutex:
        def __new__(cls) -> QueueSynchronizer.CommonMutex: ...

        async def wait(self, key: QueueMessage.MessageKey, callback: Coroutine) -> NoReturn: ...

    def __new__(cls) -> QueueSynchronizer: ...

    def __call__(self, orig_message: Message) -> QueueMessage: ...


class QueueBot(BaseBot):
    def __init__(self, token: str, *, group_id: int) -> NoReturn: ...
