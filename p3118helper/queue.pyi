from types import MappingProxyType
from typing import NoReturn, Tuple, final, ClassVar, Coroutine, Optional, overload, Union, MappingView, Iterable, Iterator

from aiogram.types import Message, CallbackQuery

from ._base import BaseBot


class QueueStruct:
    @final
    class user:
        def __new__(cls, uid: int, display_name: str) -> QueueStruct.user: ...

        @property
        def uid(self, /) -> int: ...

        @uid.setter
        def uid(self, value: int, /) -> NoReturn: ...

        @property
        def display_name(self, /) -> str: ...

        @display_name.setter
        def display_name(self, value: str, /) -> NoReturn: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

    @final
    class QueueSlot:
        @property
        def uid(self, /) -> Optional[int]: ...

        @property
        def display_name(self, /) -> Optional[str]: ...

        @display_name.setter
        def display_name(self, value: str, /) -> NoReturn: ...

        @property
        def queue(self, /) -> QueueStruct.Queue: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

        def __bool__(self, /) -> bool: ...

        def clear(self, /) -> NoReturn: ...

        def fill(self, data: QueueStruct.user, /) -> NoReturn: ...

        def up(self, /) -> QueueStruct.QueueSlot: ...

        def down(self, /) -> QueueStruct.QueueSlot: ...

        def pop(self, /) -> NoReturn: ...

        def insert_before(self, data: Optional[QueueStruct.user], /) -> QueueStruct.QueueSlot: ...

        def insert_after(self, data: Optional[QueueStruct.user], /) -> QueueStruct.QueueSlot: ...

    @final
    class Queue:
        @final
        class forward_iterator:
            def __str__(self, /) -> str: ...

            def __repr__(self, /) -> str: ...

            def __iter__(self, /) -> QueueStruct.Queue.forward_iterator: ...

            def __next__(self, /) -> QueueStruct.QueueSlot: ...

        @final
        class reverse_iterator:
            def __str__(self, /) -> str: ...

            def __repr__(self, /) -> str: ...

            def __iter__(self, /) -> QueueStruct.Queue.forward_iterator: ...

            def __next__(self, /) -> QueueStruct.QueueSlot: ...

        @property
        def name(self, /) -> Optional[str]: ...

        @property
        def index(self) -> int: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

        def __len__(self, /) -> int: ...

        def __getitem__(self, index: int, /) -> QueueStruct.QueueSlot: ...

        def __iter__(self, /) -> forward_iterator: ...

        def __reversed__(self, /) -> reverse_iterator: ...

    @final
    class slot_iterator:
        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

        def __iter__(self, /) -> QueueStruct.Queue.forward_iterator: ...

        def __next__(self, /) -> QueueStruct.QueueSlot: ...

    @property
    def name(self, /) -> str: ...

    @property
    def final(self, /) -> bool: ...

    @final.setter
    def final(self, v: bool, /) -> NoReturn: ...

    @overload
    def __new__(cls, /, name: str, final: bool, queues: Union[dict[str, Iterable[Optional[user]]], MappingProxyType[str, Iterable[Optional[user]]]]) -> QueueStruct: ...

    @overload
    def __new__(cls, /, name: str, final: bool, queues: Iterable[Optional[user]]) -> QueueStruct: ...

    def __len__(self, /) -> int: ...

    def __getitem__(self, index, /) -> Queue: ...

    def __str__(self, /) -> str: ...

    def __repr__(self, /) -> str: ...

    def __iter__(self, /) -> Iterator[Queue]: ...

    def __reversed__(self, /) -> Iterator[Queue]: ...

    def iter_slots(self, /) -> slot_iterator: ...

    def find_user(self, uid: int, /) -> Optional[QueueSlot]: ...

    def push(self, data: user, i: int = 0, /) -> QueueSlot: ...

    def finalize(self, /) -> NoReturn: ...

    def open(self, /) -> NoReturn: ...


class QueueMessage(QueueStruct):
    @final
    class message_key:
        @property
        def chat(self, /) -> int: ...

        @property
        def message(self, /) -> int: ...

        def __new__(cls, /, chat: int, message: int) -> QueueMessage.message_key: ...

        @classmethod
        def from_message(cls, message: Message, /) -> QueueMessage.message_key: ...

        def __str__(self, /) -> str: ...

        def __repr__(self, /) -> str: ...

        def __hash__(self, /) -> int: ...

        def __eq__(self, other: QueueMessage.message_key, /) -> bool: ...

    class ParseError(ValueError):
        pass

    @property
    def key(self) -> message_key: ...

    @overload
    def __new__(
            cls,
            name: str,
            final: bool,
            queues: Union[dict[str, Iterable[Optional[QueueStruct.user]]], MappingProxyType[str, Iterable[Optional[QueueStruct.user]]]],
            message: Message,
            mutex: QueueSynchronizer.CommonMutex
    ) -> QueueMessage: ...

    @overload
    def __new__(
            cls,
            name: str,
            final: bool,
            queues: Iterable[Optional[QueueStruct.user]],
            message: Message,
            mutex: QueueSynchronizer.CommonMutex
    ) -> QueueMessage: ...

    @classmethod
    def parse(cls, message: Message, mutex: QueueSynchronizer.CommonMutex) -> QueueMessage: ...

    def dump(self: QueueStruct) -> str: ...

    def user_synced(self, uid: int) -> bool: ...

    def sync_user(self, uid: int) -> bool: ...

    async def update(self) -> NoReturn: ...


class QueueSynchronizer:
    DELAY: ClassVar[float] = ...

    class CommonMutex:
        def __new__(cls) -> QueueSynchronizer.CommonMutex: ...

        async def wait(self, key: QueueMessage.message_key, callback: Coroutine) -> NoReturn: ...

    def __new__(cls) -> QueueSynchronizer: ...

    def __call__(self, orig_message: Message) -> QueueMessage: ...


class QueueBot(BaseBot):
    def __init__(self, token: str, *, group_id: int) -> NoReturn: ...
